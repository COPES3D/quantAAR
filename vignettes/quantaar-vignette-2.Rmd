---
title: "Surface kriging and object attribution for small scale excavations"
author: "Clemens Schmid"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spit attribution for small scale excavations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
if (!requireNamespace("plotly", quietly = TRUE)) {
  stop("plotly needed for this vignette to build.",
    call. = FALSE)
}
```

First we need to load quantaar and some external packages:

- **dplyr**: filter function
- **kriging**: simple surface modelling tool
- **magrittr**: introduces piping to R via %>% operator
- **plotly**: nice, interactive plots via javascript implementation

```{r, message=FALSE}
devtools::load_all()
library(dplyr)
library(kriging)
library(magrittr)
library(plotly)
```

Now let's imagine an artificial and pretty simple excavation trench with a depth of 2 meters, a length of 3 meters and a width of 1 meter. 

```{r}
edges <- data.frame(
  x = c(0, 3, 0, 3, 0, 3, 0, 3),
  y = c(0, 0, 0, 0, 1, 1, 1, 1),
  z = c(0, 0, 2, 2, 0, 0, 2, 2)
)
```

We can plot the corner points of this trench:

```{r fig.width=7, fig.height=5}
vis <- plot_ly(edges, x = x, y = y, z = z, type = "scatter3d", mode = "markers"
  ) %>% 
  layout(
    showlegend = FALSE,
    autorange = F, 
    aspectmode = 'manual', 
    scene = list(
      dragmode = "orbit",
      aspectratio = list(x=3, y=1, z=3),
      camera = list(
        eye = list(x = 4, y = 4, z = 1) 
      )
    )
  )

vis
```

When we look at the profiles of our fictional trench we can trace three clearly separated horizons. Let's figuratively take some measurements of the two horizon borders by creating two data.frames with points along the profiles. The z-axis values are randomly computed.  

```{r}
df1 <- data.frame(
  x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)), 
  z = c(1+0.1*rnorm(6), 1+0.1*rnorm(14), 0.8+0.1*rnorm(14), 0.8+0.1*rnorm(6))
)

df1

df2 <- data.frame(
  x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
  z = c(0.5+0.1*rnorm(6), 0.5+0.1*rnorm(14), 0.4+0.1*rnorm(14), 0.4+0.1*rnorm(6))
)
```

```{r fig.width=7, fig.height=5}
vis <- vis %>%
  add_trace(data = df1, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 4, color = "green", symbol = 104)
  ) %>%
  add_trace(data = df2, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 4, color = "blue", symbol = 104)
  ) 

vis
```

We can put this two or even more data.frames with observations into a list and feed it to \code{quantaar::kriglist}. This function serves as an interface to \code{kriging::kriging}. We'll get a list list of data.frames with surface estimations for the two input layers. 

```{r }
lpoints <- list(df1, df2)

maps <- kriglist(lpoints, lags = 3, model = "spherical")
```

As the result of \code{kriging::kriging} is in a tall format, we have to make it wide to plot it. For this purpose we use \code{quantaar::spatialwide}.

```{r fig.width=7, fig.height=5}
surf1 <- spatialwide(maps[[1]]$x, maps[[1]]$y, maps[[1]]$pred, 3)
surf2 <- spatialwide(maps[[2]]$x, maps[[2]]$y, maps[[2]]$pred, 3)

x1 <- as.numeric(colnames(surf1))
y1 <- as.numeric(rownames(surf1))
z1 <- as.matrix(surf1)
x2 <- as.numeric(colnames(surf2))
y2 <- as.numeric(rownames(surf2))
z2 <- as.matrix(surf2)

vis <- vis %>% 
  add_trace(x = x1, y = x1, z = z1, type = "surface", showscale = FALSE
  ) %>%
  add_trace(x = x2, y = x2, z = z2, type = "surface", showscale = FALSE
  ) 

vis
```

```{r fig.width=7, fig.height=5}
hexatestdf <- data.frame(
  x = c(1.5, 1.5, 2.2, 1.8, 1.3, 1.2, 1.7, 2),
  y = c(0.2, 0.6, 0.2, 0.6, 0.15, 0.35, 0.2, 0.6),
  z = c(0.2, 0.1, 0.2, 0.1, 1.5, 1.6, 1.5, 1.6)
)

cx = fillhexa(hexatestdf, 0.05)

cuberasterlist <- list(cx)

vis %>% 
  add_trace(data = cx, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "red", symbol = 104)
  )
```

```{r fig.width=7, fig.height=5}
crlist <- posdeclist(cuberasterlist, maps)

hexa <- crlist[[1]]

a <- filter(
  hexa,
  pos == 0
)

b <- filter(
  hexa,
  pos == 1
)

c <- filter(
  hexa,
  pos == 2
)

vis %>% add_trace(data = a, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#31a354", symbol = 104)
  ) %>% add_trace(data = b, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#de2d26", symbol = 104)
  ) %>% add_trace(data = c, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#2b8cbe", symbol = 104)
  )
```

```{r}
# deci: create a result data.frame which shows the distribution of cube points
deci <- function (crlist) {
  
  # determine amount of layers
  nl = max(unlist(lapply(crlist, function(x) max(x$pos, na.rm=T))))
  # create result data.frame
  m <- matrix(NA, ncol = nl+1, nrow = 1)
  pos <- data.frame(m)
  names(pos) <- c(0:nl)
  # calculate distribution
  for (crp in 1:length(crlist)) {
    cr <- crlist[[crp]]
    crd <- sort(unique(cr$pos))
    ncr <- nrow(cr)
    for (i in 1:length(crd)) {
      pos[crp, names(pos) == crd[i]] <- nrow(filter(cr, pos == crd[i]))/ncr*100
    }
  }
  return(pos)
}

deci(crlist)
```